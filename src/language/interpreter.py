import sys

import math

from antlr4 import FileStream, CommonTokenStream, ParseTreeWalker, InputStream

from src.language.anltr.MiniLanguageLexer import MiniLanguageLexer
from src.language.anltr.MiniLanguageParser import MiniLanguageParser

from antlr4.error.ErrorListener import ErrorListener


class CustomErrorListener(ErrorListener):
    """
    Custom error listener for ANTLR4.
    """

    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):
        raise Exception(f"Syntax error at line {line}:{column} {msg}")


def convert_to_type(text):
    """
    Utility function for converting text to int, float or bool.
    """

    if not isinstance(text, str):
        return text

    try:
        # Spróbuj zamienić na int
        result = int(text)
        return result
    except ValueError:
        try:
            # Spróbuj zamienić na float
            result = float(text)
            return result
        except ValueError:
            # Spróbuj zamienić na bool (obsługując "True" i "False" bez względu na wielkość liter)
            if text.lower() == "true":
                return True
            elif text.lower() == "false":
                return False
            else:
                # Jeśli nie udało się zamienić na żaden z powyższych, zwróć oryginalny tekst
                return text


class InstructionsLimitExceeded(Exception):
    """
    Custom exception for interrupting execution of the program when limit of instructions is exceeded.
    """

    pass


class MiniLanguageInterpreter:
    """
    Interpreter for the prepared language, uses a lexer and parser generated by ANTLR4.
    """

    def __init__(
        self,
        testing: bool = False,
        input_from_list: bool = True,
        limit_of_instructions: int = math.inf,
        verbose: bool = False,
    ):
        self.testing = (
            testing  # for printing place where you are now, and dict of variables
        )
        self.input_from_list = input_from_list
        self.limit_of_instructions = limit_of_instructions
        self.verbose = verbose

    def run(self, program: str, inputs: list = [0]) -> list:
        stream = InputStream(program)
        lexer = MiniLanguageLexer(stream)
        stream = CommonTokenStream(lexer)
        parser = MiniLanguageParser(stream)

        parser.removeErrorListeners()
        parser.addErrorListener(CustomErrorListener())

        try:
            tree = (
                parser.program()  # 'program' is the name of the starting rule in MiniLanguage.g4
            )
        except Exception as e:
            print("Exception occurred:", e)
            print("Program:", program)

        if not inputs:
            inputs = [0]
        self.inputs = inputs
        self.iterator = 0
        self.variables = {}
        self.outputs = []

        self.executed_instructions = 0

        try:
            self.visitProgram(tree)
        except InstructionsLimitExceeded:
            print("Limit of instructions exceeded.")
        except ZeroDivisionError:
            if self.verbose:
                print("Division by zero.")
        except Exception as e:
            print("Exception occurred:", e)
            print("Program:", program)

        return self.outputs

    def run_from_file(self, input_file: str, inputs: list = [0]) -> list:
        input_stream = FileStream(input_file)
        lexer = MiniLanguageLexer(input_stream)
        stream = CommonTokenStream(lexer)
        parser = MiniLanguageParser(stream)
        tree = (
            parser.program()  # 'program' is the name of the starting rule in MiniLanguage.g4
        )

        self.inputs = inputs
        self.iterator = 0
        self.variables = {}
        self.outputs = []

        self.executed_instructions = 0

        try:
            self.visitProgram(tree)
        except InstructionsLimitExceeded:
            print("Limit of instructions exceeded.")
        except Exception as e:
            print("Exception occurred:", e)

        return self.outputs

    def interrupt(function):
        """
        Decorator for interrupting execution of the program when limit of instructions is exceeded.
        """

        def wrapper(*args, **kwargs):
            _self = args[0]
            if _self.executed_instructions >= _self.limit_of_instructions:
                raise InstructionsLimitExceeded
            _self.executed_instructions += 1
            return function(*args, **kwargs)

        return wrapper

    def visitProgram(self, ctx):
        if self.testing:
            print("program")

        for statement in ctx.statement():
            self.visitStatement(statement)
        if self.testing:
            print(self.variables)
            print(self.outputs)

    @interrupt
    def visitStatement(self, ctx):
        if self.testing:
            print("statement", ctx)

        if ctx.assignment():
            self.visitAssignment(ctx.assignment())
        elif ctx.loop():
            self.visitLoop(ctx.loop())
        elif ctx.conditional():
            self.visitConditional(ctx.conditional())
        elif ctx.block():
            self.visitBlock(ctx.block())
        elif ctx.input_():
            self.visitInput(ctx.input_())
        elif ctx.output():
            self.visitOutput(ctx.output())

    def visitAssignment(self, ctx):
        if self.testing:
            print("assignment")

        variable = convert_to_type(ctx.VAR_ID().getText())
        expression_result = self.visitExpression(ctx.expression())
        if self.testing:
            print(f"Variable '{variable}' assigned the value: {expression_result}")
        self.variables[variable] = expression_result

    def visitLoop(self, ctx):
        if self.testing:
            print("loop")

        while condition := self.visitCondition(ctx.condition()):
            self.visitBlock(ctx.block())

    def visitConditional(self, ctx):
        if self.testing:
            print("conditional")

        if condition := self.visitCondition(ctx.condition()):
            self.visitBlock(ctx.block(0))
        elif ctx.block(1):
            self.visitBlock(ctx.block(1))

    def visitBlock(self, ctx):
        if self.testing:
            print("block")

        for statement in ctx.statement():
            self.visitStatement(statement)

    def visitInput(self, ctx):
        if self.testing:
            print("input")

        variable = ctx.id_().getText()
        value = None
        if not self.input_from_list:
            value = convert_to_type(input(f"Enter value for '{variable}': "))
        else:
            value = convert_to_type(self.inputs[self.iterator])
            self.iterator += 1
            if self.iterator >= len(self.inputs):
                self.iterator = 0

        # Handle different types if necessary
        self.variables[variable] = value
        if self.testing:
            print(f"Variable '{variable}' INPUTICALLY assigned the value: {value}")
        return value

    def visitOutput(self, ctx):
        if self.testing:
            print("output")

        value = self.visitExpression(ctx.expression())
        if self.testing:
            print(f"Output: {value}")
        self.outputs.append(value)

    def visitExpression(self, ctx):
        if self.testing:
            print("expression")

        if ctx.numericalExpression():
            return self.visitNumericalExpression(ctx.numericalExpression())
        else:
            return self.visitLogicExpression(ctx.logicExpression())

    def visitNumericalExpression(self, ctx):
        if self.testing:
            print("numericalexpression")

        # Handle numerical expressions
        result = self.visitTerm(ctx.term(0))
        for i in range(1, len(ctx.term())):
            op = ctx.getChild(2 * i - 1).getText()
            right = self.visitTerm(ctx.term(i))
            if op == "+":
                result += right
            elif op == "-":
                result -= right
        return result

    def visitTerm(self, ctx):
        if self.testing:
            print("term")

        # Handle terms in numerical expressions
        result = self.visitFactor(ctx.factor(0))
        for i in range(1, len(ctx.factor())):
            op = ctx.getChild(2 * i - 1).getText()
            right = self.visitFactor(ctx.factor(i))
            if op == "*":
                result *= right
            elif op == "/":
                result /= right
        return result

    def visitFactor(self, ctx: MiniLanguageParser.FactorContext):
        if self.testing:
            print("factor")

        # Handle factors in numerical expressions
        if ctx.id_():
            return self.visitId(ctx.id_())
        elif ctx.FLOAT():
            return float(ctx.FLOAT().getText())
        elif ctx.INT():
            return int(ctx.INT().getText())
        elif ctx.numericalExpression():
            return self.visitNumericalExpression(ctx.numericalExpression())
        elif ctx.factor():
            return -self.visitFactor(ctx.factor())
        else:
            return None

    def visitId(self, ctx):
        if self.testing:
            print("id")

        if self.input_from_list and not ctx.getText() in self.variables.keys():
            value = convert_to_type(self.inputs[self.iterator])
            self.iterator += 1
            if self.iterator >= len(self.inputs):
                self.iterator = 0
            self.variables[ctx.getText()] = value

            if self.testing:
                print(
                    f"Variable '{ctx.getText()}' AUTOMATICALLY assigned the value: {value}"
                )

        return self.variables[ctx.getText()]

    def visitCondition(self, ctx):
        if self.testing:
            print("condition")

        if ctx.logicExpression():
            return self.visitLogicExpression(ctx.logicExpression())
        else:
            print("to nie logicExpression, w visitCondition")

    def visitLogicExpression(self, ctx):
        if self.testing:
            print("logicExpression")

        # Handle logic expressions
        left = self.visitLogicTerm(ctx.logicTerm(0))
        for i in range(1, len(ctx.logicTerm())):
            op = ctx.getChild(2 * i - 1).getText()
            right = self.visitLogicTerm(ctx.logicTerm(i))
            if op == "and":
                left = left and right
            elif op == "or":
                left = left or right
        return left

    def visitLogicTerm(self, ctx):
        if self.testing:
            print("logicTerm")

        # Handle logic terms
        left = self.visitLogicFactor(ctx.logicFactor(0))
        for i in range(1, len(ctx.logicFactor())):
            op = ctx.getChild(2 * i - 1).getText()
            right = self.visitLogicFactor(ctx.logicFactor(i))
            if op == "and":
                left = left and right
            elif op == "or":
                left = left or right
        return left

    def visitLogicFactor(self, ctx):
        if self.testing:
            print("logicFactor")

        # Handle logic factors
        if ctx.id_():
            return self.visitId(ctx.id_())
        elif ctx.BOOL():
            return True if ctx.BOOL().getText() == "True" else False
        elif ctx.logicFactor():
            return not self.visitLogicFactor(ctx.logicFactor())
        elif ctx.logicExpression():
            return self.visitLogicExpression(ctx.logicExpression())
        elif ctx.relationalExpression():
            return self.visitRelationalExpression(ctx.relationalExpression())
        else:
            return None

    def visitRelationalExpression(self, ctx):
        if self.testing:
            print("relationExpression")

        # Handle relational expressions
        left = self.visitNumericalExpression(ctx.numericalExpression(0))
        op = ctx.getChild(1).getText()
        right = self.visitNumericalExpression(ctx.numericalExpression(1))
        if op == "==":
            return left == right
        elif op == "!=":
            return left != right
        elif op == "<":
            return left < right
        elif op == ">":
            return left > right
        elif op == "<=":
            return left <= right
        elif op == ">=":
            return left >= right
        else:
            return None


# to run use a command: python interpreter.py <input_file> [<inputs>], e.g. python interpreter.py "input.txt" "1, 100"
def main():
    match len(sys.argv):
        case 1:
            raise Exception("No input file provided.")
        case 2:
            input_file = sys.argv[1]
            inputs = [0]
        case 3:
            input_file = sys.argv[1]
            inputs = sys.argv[2].split(",")
        case _:
            raise Exception("Too many arguments provided.")

    interpreter = MiniLanguageInterpreter(limit_of_instructions=5)
    print(interpreter.run(input_file, inputs))


if __name__ == "__main__":
    main()
